## Мысли и советы из книги Sam Newman "Building Microservices"

1. **Bounded context** из DDD отлично описывает один микросервис. Если определить все главные **bounded contexts**, то можно каждый выделить в сервис, а каждый сервис может содержать свои внутренние **bounded contexts**.

2. Систему можно начинать проектировать и делать как монолитную в одном солюшне для того чтобы постепенно проявить все внутренние (использующиеся внутри сервиса) и внешние (использующиеся для передачи данных между сервисами) **модели** и **bounded contexts**. Затем, когда все проясниться и устаканиться, можно ее (систему) разбить на микросервисы. **Это совет для новичков**. С опытом систему можно сразу проектировать как микросервисную.

3. При проектировании микросервисов необходимо думать в **контексте возможностей (capabilities)** проектируемого сервиса и того **что он умеет делать**, а не данных которыми он оперирует, иначе выйдет просто CRUD вокруг которого строится сервис. А когда эти возмоности и способности определены - уже можно выделять данные и модели, которые нужны для реализации этих спосбностей.

4. Вариант общения клиента и сервера: гуглить **Richardson Maturity Model и Hypermedia Controls (HATEOAS)**. Фаулер об этом писал, подход прикольный, но походу не получил популярность.

5. Микросервисы должны иметь **low coupling** между друг другом и **high cohesion** внутри себя, что логично. Но **shared** между сервисами база данных или **библиотека с data types** для всех сервисов в итоге неявно увеличивает **coupling**. Кроме того, создание библиотеки клиента для сервиса и использование ее в разных клиентах этого сервиса тоже создает **coupling** между **ВСЕМИ** клиентами и сервисом. Принцип **DRY** тоже можно и нужно нарушать в угоду независимости сервисов друг от друга. Лучше скопипастить какой-то кусок кода с бизнес логикой чем выделять его в библиотеку и шарить ее между сервисами (речь не идет вспомогательных библиотеках типа log4net).

6. Согласно автору **асинхронная event-based** коммуникация между микросервисами через **message broker** типа Rabbit MQ является лучшим вариантом реализации архитектуры микросервисов, так как имеет наименьший **coupling** и микросервисы не знают друг о друге.

7. UI layer за которым стоит множество микросервисов может общаться с ними следующим образом:
	* UI компонент, который шлет запросы всем необходимым сервисам
		&#9989; SRP, UI сам за себя отвечает и знает что ему нужно
		&#10060; сообщения могут слаться рассинхронизированно, что жрет много трафика, что критично для мобильной сети
		&#10060; для получения всей информации надо общаться с несколькими сервисами, т.е. происходит интенсивное использование сети
		&#10060; скорее всего понадобиться выделенная команда для поддержи UI, а это значит необходима коммуникация между командами, теряется независимость
		&#10060; увеличиватся **coupling** между сервисами и UI
	* Каждый сервис представляет свой UI виджет. Все они собираются в некий box и показываются пользователю.  
		&#9989; UI каждого сервиса сапортится командой этого сервиса и нет нужды в выделенной UI команде
		&#9989; **coupling** между UI и сервисами в порядке
		&#10060; сообщения все равно могут слаться рассинхронизированно, что жрет много трафика, что критично для мобильной сети
		&#10060; для получения всей информации надо общаться с несколькими сервисами, т.е. происходит интенсивное использование сети
		&#10060; в случае появления виджета, которому необходимы данные нескольких сервисов снова увеличивается **coupling**		
	* **API Gateway**, что по сути является **фасадом** ко всем сервисам. 
		&#9989; сервисы и UI независимы друг от друга и развязаны через Gateway
		&#9989; данные из разныих сервисов могут быть получены UI одном запросом к фасаду, который уже сам знает какие сервисы ему запросить
		&#10060; при изменении одного сервиса меняется фасад
		&#10060; фасад может разрастись до огромных размеров и его будет тяжело поддерживать, особенно если учитывать разные виды UI (mobile, web, admin panel) которые могут иметь потребности в разных сервисах, но в итоге объединенный одним фасадом
	* Альтернативой, поддерживаемой автором, является **Гибридный подход**, где каждый вид UI (mobile, web, admin panel) имеет свой **API Gateway**
		&#9989; сервисы и UI независимы друг от друга и развязаны через Gateway
		&#9989; разные виды UI независимы друг от друга и от сервисов
		&#9989; данные из разныих сервисов могут быть получены UI одном запросом к фасаду, который уже сам знает какие сервисы ему запросить
		&#9989; меньше шансов, что фасад разрастется до огромных размеров
		&#9989; при изменении одного сервиса меняется только зависимый фасад, если таковой есть
		&#10060; необходимо поддерживать больше одного фасада
		&#10060; возможно понадобится выделенная команда, с которой другим надо коммуницировать, что уменьшает независимость
		&#10060; при изменении сервиса используемого в нескольких фасадах, их придется менять все
