# CSharp and .NET

## Dynamic

- В С# 4 допускается встраивание нужных частей основной сборки взаимодействия (primaryinteropassembly - РІА) в вызывающий код, поэтому отпадает необходимость в отдельном развертывании сборки РІА. Вместо ссылки на сборку РІА подобно любой другой сборке можно связать ее ( **Jon Skeet** )

- Распознавание, какую версию перегруженной метода вызвать происходит за счет статического типа объявленной переменной, даже если переменная содержит наследник, например. Пример:

Есть 2 метода

**_1) Execute(dynamic a, object b)_**
**_2) Execute(dynamic a, string b)_**

Переменная **_object text = "string";_** объявлена как **object**, поэтому будет вызван **1)**. Если бы переменная **text** была бы объявлена как *_dynamic_*, то вызвался бы **2)**, поскольку идет выяснение *_действительного_* типа переменной.

- Нужендля **reflection**, **COM interop**, **interop with dynamic languages**

- Явная реализация интерфейсов и dynamic сочетаются плохо

- Жизненный цикл обработки динамического выражения

 ![Схема работы Dynamic](https://github.com/SergeyUsok/SelfEducationNotes/blob/master/img/DotNET/Dynamic.png)

## Struct

- Структуры выгодно использовать из-за их легковесности (на содержат лишней информации как объекты), но **структуры всегда копируются при передаче в метод или при возращении из него** , а значит, что тяжелая структура всегда копируется и возможно проще использовать класс. ( **Jon Skeet** )

## Miscellaneous

- Система типов C#1 является статической (с появлением **dynamic** есть изменения), явной ( **var** это изменил) и безопасной. ( **Jon Skeet** )

- public event EventHandler Click = delegate {}; // делегатпоумолчанию

- просто к сведению:

1) **уточнитель пространства имен ::**

2) псевдоним глобального пространства имен **global**** ::**

3) внешние псевдонимы **extern**** alias**

4) буфер фиксированного размера в **unsafe**** :**

**fixed**** byte ****data**** [20]; //** массив из 20 байтов; это позволяет работать с полем data так, как будто оно имело тип byte\*

- Два инициализатора анонимных объектов с одинаковыми именами свойств, следующими в том же самом порядке, но имеющими отличающиеся типы, приводят к созданию двух разных типов, на самом деле они генерируются из **одного обобщенного типа**

- Join метод Linq загружает в память inner последовательность, а по outer идет потоком. Выгодней inner делатьнебольшуюпоследовательность.

- SortedList<Key,Value> - list backed collection

- SortedDictionary<Key,Value> - tree backed collection (красно-черноедерево)

- **Any CPU 32-bit preferred –** всегда компилится под 32 бит, просто поддерживает ARM из коробки
