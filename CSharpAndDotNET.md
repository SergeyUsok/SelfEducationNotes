# CSharp and .NET

## Dynamic

- В С# 4 допускается встраивание нужных частей основной сборки взаимодействия (primaryinteropassembly - РІА) в вызывающий код, поэтому отпадает необходимость в отдельном развертывании сборки РІА. Вместо ссылки на сборку РІА подобно любой другой сборке можно связать ее (**Jon Skeet**)

- Распознавание, какую версию перегруженной метода вызвать происходит за счет статического типа объявленной переменной, даже если переменная содержит наследник. Пример:

Есть 2 метода:

**_1) Execute(dynamic a, object b)_**

**_2) Execute(dynamic a, string b)_**

Переменная **_object text = "string";_** объявлена как **object**, поэтому будет вызван **1)**. Если бы переменная **text** была бы объявлена как **_dynamic_**, то вызвался бы **2)**, поскольку идет выяснение **_действительного_** типа переменной.

- Нужен для **reflection**, **COM interop**, **interop with dynamic languages**

- Явная реализация интерфейсов и dynamic сочетаются плохо

- Жизненный цикл обработки динамического выражения:

 ![Схема работы Dynamic](https://github.com/SergeyUsok/SelfEducationNotes/blob/master/img/DotNET/Dynamic.png)

## Struct

- Структуры выгодно использовать из-за их легковесности (на содержат лишней информации как объекты), но **структуры всегда копируются при передаче в метод или при возращении из него** , а значит, что тяжелая структура всегда копируется и возможно проще использовать класс. ( **Jon Skeet** )

## Miscellaneous

- Система типов C#1 является статической (с появлением **dynamic** есть изменения), явной ( **var** это изменил) и безопасной. ( **Jon Skeet** )

- public event EventHandler Click = delegate {}; // делегат по умолчанию

- namespaces hints:

     + **уточнитель пространства имен ::**    

     + псевдоним глобального пространства имен **global ::**    

     + внешние псевдонимы **extern alias**    

- буфер фиксированного размера в **unsafe :**    

     + **fixed byte data [20];** // массив из 20 байтов; это позволяет работать с полем data так, как будто оно имело тип byte\*

- Два инициализатора анонимных объектов с одинаковыми именами свойств, следующими в том же самом порядке, но имеющими отличающиеся типы, приводят к созданию двух разных типов, на самом деле они генерируются из **одного обобщенного типа**

- Join метод Linq загружает в память именно **inner** последовательность, а по **outer** идет потоком. Выгодней inner делать небольшую последовательность.

- SortedList<Key,Value> - list backed collection

- SortedDictionary<Key,Value> - tree backed collection (красно-черное дерево)

- **Any CPU 32-bit preferred –** всегда компилится под 32 бит, просто поддерживает ARM из коробки

## TPL, Async and PLINQ
- В библиотечных методах лучше не использовать **Task.Run**. Пусть пользователь сам решит, надо ли ему многопоточность. Для имитации асинхронности тоже его не надо использовать, либо **async/await**, либо синхронный код
- **void** в async методах использовать только для обработчиков событий, поскольку это fire-and-forget, то можно попасть в ситуацию пропущенного исключения или чего-то подобного.
- При использовании async/await не гарантии, что метод будет выполняться асинхронно, поскольку в целях оптимизации CLR вполне может выполнить его синхронно. **Task.Yield()** позволяет явно сказать, что Continuation должен выполняться в другом потоке, т.е. он **forcibly fork method control flow**
- **Task.Delay()** можно использовать как **timeout**. Например, var task = Task.WhenAny(BusinessTask, Task.Delay(3000)), где BusinessTask - это нужная там таска, второй параметр - это **timeout**. Таким образом, если первой закончится таска **Task.Delay(3000)**, то это можно обрабатывать как **timeout expiration**.
- Метод PLINQ **ForAll()** отличается от обычного **foreach** тем, что он поребляет результаты в разных потоках, в то время как **foreach** обрабатывет все в одном потоке, в котором он собственнно и объявлен, поэтому предварительно необходимо объединить все результаты в один поток.
Разница работы в схеме: https://i-msdn.sec.s-msft.com/dynimg/IC387953.jpeg
- Платформа PLINQ не помещает одно исключение **OperationCanceledException** в исключение System.AggregateException. Исключение OperationCanceledException должно обрабатываться в отдельном блоке catch. Если один или несколько пользовательских делегатов создают исключение **OperationCanceledException()** и не создают другого исключения, а запрос был определен как AsParallel().WithCancellation(externalCT), PLINQ сгенерирует одно исключение **OperationCanceledException(externalCT)** вместо System.AggregateException. Однако если один пользовательский делегат создает исключение OperationCanceledException, а другой делегат создает другой тип исключения, оба исключения помещаются в AggregateException.
- Чтобы обеспечить отклик системы, рекомендуется проверять **CancellationToken** из пользоватльского кода приблизительно каждую **миллисекунду**. Однако допускается любой период **до 10 миллисекунд**.Эта частота не должна оказывать отрицательное влияние на производительность кода
- Когда цикл **Parallel.For** имеет небольшое тело (быстро выполняется), сам цикл может выполняться медленне чем обычный **for**. Снижение производительности происходит из-за нагрузки, связанной с секционированием данных **(partitioning)** и стоимостью вызова делегата в каждой итерации цикла. Для разрешения таких сценариев можно юзать метод Partitioner.Create, который позволяет выполнять последовательный цикл для тела делегата, чтобы делегат вызывался только один раз для каждой секции, а не по разу в каждой итерации. То есть имеется в виду, что мы заранее партицируем данные. Пример кода: https://msdn.microsoft.com/ru-ru/library/dd560853(v=vs.110).aspx
- **Task.Factory.StartNew()** есть перегрузка которая принимает **Object**, который модно назанчить как состояние задачи. Это может быть любой объект. Доступ к нему во время инициализации задачи осуществляется из **Action(Object)**, а во время работы с задачей его можно взять из свойства **Task.AsyncState**.

## C# 6.0 features:
https://github.com/dotnet/roslyn/wiki/New-Language-Features-in-C%23-6
